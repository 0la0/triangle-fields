{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/bit-twiddle/twiddle.js","webpack://exports/./node_modules/delaunay-triangulate/triangulate.js","webpack://exports/./node_modules/incremental-convex-hull/ich.js","webpack://exports/./node_modules/robust-orientation/orientation.js","webpack://exports/./node_modules/robust-scale/robust-scale.js","webpack://exports/./node_modules/robust-subtract/robust-diff.js","webpack://exports/./node_modules/robust-sum/robust-sum.js","webpack://exports/./node_modules/simplicial-complex/topology.js","webpack://exports/./node_modules/two-product/two-product.js","webpack://exports/./node_modules/two-sum/two-sum.js","webpack://exports/./node_modules/union-find/index.js","webpack://exports/./node_modules/uniq/uniq.js","webpack://exports/./src/entry-points/index.js","webpack://exports/./src/geometry/Line.js","webpack://exports/./src/geometry/Oval.js","webpack://exports/./src/geometry/Point.js","webpack://exports/./src/geometry/Triangle.js","webpack://exports/./src/main/triangle-field.js","webpack://exports/./src/util/Intersection.js","webpack://exports/./src/util/Math.js","webpack://exports/external \"sketch\"","webpack://exports/external \"sketch/dom\""],"names":["context","sketchObject","selection","firstObject","document","showMessage","triangleField","createLine","p1","p2","path","NSBezierPath","bezierPath","moveToPoint","NSMakePoint","getX","getY","lineToPoint","shape","MSShapeGroup","shapeWithBezierPath","MSPath","pathWithBezierPath","border","style","addStylePartOfType","color","MSColor","colorWithRGBADictionary","getRandomColor","thickness","name","Line","id","getId","sort","a","b","reduce","acc","num","createOval","centerPoint","radius","ovalShape","MSOvalShape","alloc","init","frame","MSRect","rectWithRect","NSMakeRect","shapeGroup","shapeWithPath","fill","Oval","center","clone","sub","Point","x","y","scalar","p","createTriangle","p3","closePath","Triangle","FIELD_SIZE","getBounds","points","dimensions","minX","Number","MAX_VALUE","maxX","MIN_VALUE","minY","maxY","fieldDimensions","dims","point","rangeX","rangeY","createField","numPoints","edgePoints","centroid","getCentroid","bounds","length","potentialPoint","getRandomNum","pointIsInsidePolygon","push","getPointsFromShape","pathInFrameWithTransforms","bezierPathWithPath","Math","floor","stride","indices","Array","map","n","i","pointOnPathAtLength","index","numEdgePoint","page","currentPage","pointField","allPoints","concat","pointArray","triangleIndices","delaunayTriangulate","trianglePoints","i0","i1","i2","p0","lineLayers","line0","line1","line2","uniqueList","triangleLines","forEach","some","_line","line","getShape","triangleLayers","triangle","pointLayers","oval","parentGroup","parent","triangleGroup","layers","lineGroup","pointGroup","adjustToFit","ORIENTATION","COLINEAR","CLOCKWISE","COUNTERCLOCKWISE","onSegment","q","r","max","min","getOrientation","orientation","linesDoIntersect","q1","q2","o1","o2","o3","o4","polygon","Error","extreme","count","nextIndex","getPosNeg","random","g","mult","IntArray","size","sum","s","add","multScalar"],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA,kBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1MA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC9JA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,qBAAqB;AACtD,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,cAAc,cAAc;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uC;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC7bA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+CAA+C;AACzG,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC,2BAA2B,WAAW;AACtC,+B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB,uBAAuB;AAChG;AACA,cAAc,eAAe;AAC7B,2EAA2E;AAC3E;AACA,cAAc,kCAAkC,YAAY,mBAAmB,KAAK,mBAAmB,gBAAgB;AACvH;;AAEA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;;AAEA,yB;;;;;;;;;;;;AC7LA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3JA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3Ja;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,gCAAgC,OAAO;AACvC;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA,4BAA4B,MAAM;AAClC;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA,4BAA4B,MAAM;AAClC;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,gBAAgB,YAAY;AAC5B,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,gBAAgB,YAAY;AAC5B;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrVA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AChCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChBa;;AAEb;;AAEA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,C;;;;;;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;ACxDA;AACA;AAEA,+DAAe,UAASA,OAAT,EAAkB;AAC/B,MAAMC,eAAeD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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/entry-points/index.js\");\n","/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n","\"use strict\"\n\nvar ch = require(\"incremental-convex-hull\")\nvar uniq = require(\"uniq\")\n\nmodule.exports = triangulate\n\nfunction LiftedPoint(p, i) {\n  this.point = p\n  this.index = i\n}\n\nfunction compareLifted(a, b) {\n  var ap = a.point\n  var bp = b.point\n  var d = ap.length\n  for(var i=0; i<d; ++i) {\n    var s = bp[i] - ap[i]\n    if(s) {\n      return s\n    }\n  }\n  return 0\n}\n\nfunction triangulate1D(n, points, includePointAtInfinity) {\n  if(n === 1) {\n    if(includePointAtInfinity) {\n      return [ [-1, 0] ]\n    } else {\n      return []\n    }\n  }\n  var lifted = points.map(function(p, i) {\n    return [ p[0], i ]\n  })\n  lifted.sort(function(a,b) {\n    return a[0] - b[0]\n  })\n  var cells = new Array(n - 1)\n  for(var i=1; i<n; ++i) {\n    var a = lifted[i-1]\n    var b = lifted[i]\n    cells[i-1] = [ a[1], b[1] ]\n  }\n  if(includePointAtInfinity) {\n    cells.push(\n      [ -1, cells[0][1], ],\n      [ cells[n-1][1], -1 ])\n  }\n  return cells\n}\n\nfunction triangulate(points, includePointAtInfinity) {\n  var n = points.length\n  if(n === 0) {\n    return []\n  }\n  \n  var d = points[0].length\n  if(d < 1) {\n    return []\n  }\n\n  //Special case:  For 1D we can just sort the points\n  if(d === 1) {\n    return triangulate1D(n, points, includePointAtInfinity)\n  }\n  \n  //Lift points, sort\n  var lifted = new Array(n)\n  var upper = 1.0\n  for(var i=0; i<n; ++i) {\n    var p = points[i]\n    var x = new Array(d+1)\n    var l = 0.0\n    for(var j=0; j<d; ++j) {\n      var v = p[j]\n      x[j] = v\n      l += v * v\n    }\n    x[d] = l\n    lifted[i] = new LiftedPoint(x, i)\n    upper = Math.max(l, upper)\n  }\n  uniq(lifted, compareLifted)\n  \n  //Double points\n  n = lifted.length\n\n  //Create new list of points\n  var dpoints = new Array(n + d + 1)\n  var dindex = new Array(n + d + 1)\n\n  //Add steiner points at top\n  var u = (d+1) * (d+1) * upper\n  var y = new Array(d+1)\n  for(var i=0; i<=d; ++i) {\n    y[i] = 0.0\n  }\n  y[d] = u\n\n  dpoints[0] = y.slice()\n  dindex[0] = -1\n\n  for(var i=0; i<=d; ++i) {\n    var x = y.slice()\n    x[i] = 1\n    dpoints[i+1] = x\n    dindex[i+1] = -1\n  }\n\n  //Copy rest of the points over\n  for(var i=0; i<n; ++i) {\n    var h = lifted[i]\n    dpoints[i + d + 1] = h.point\n    dindex[i + d + 1] =  h.index\n  }\n\n  //Construct convex hull\n  var hull = ch(dpoints, false)\n  if(includePointAtInfinity) {\n    hull = hull.filter(function(cell) {\n      var count = 0\n      for(var j=0; j<=d; ++j) {\n        var v = dindex[cell[j]]\n        if(v < 0) {\n          if(++count >= 2) {\n            return false\n          }\n        }\n        cell[j] = v\n      }\n      return true\n    })\n  } else {\n    hull = hull.filter(function(cell) {\n      for(var i=0; i<=d; ++i) {\n        var v = dindex[cell[i]]\n        if(v < 0) {\n          return false\n        }\n        cell[i] = v\n      }\n      return true\n    })\n  }\n\n  if(d & 1) {\n    for(var i=0; i<hull.length; ++i) {\n      var h = hull[i]\n      var x = h[0]\n      h[0] = h[1]\n      h[1] = x\n    }\n  }\n\n  return hull\n}","\"use strict\"\n\n//High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\n\nmodule.exports = incrementalConvexHull\n\nvar orient = require(\"robust-orientation\")\nvar compareCell = require(\"simplicial-complex\").compareCells\n\nfunction compareInt(a, b) {\n  return a - b\n}\n\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices\n  this.adjacent = adjacent\n  this.boundary = boundary\n  this.lastVisited = -1\n}\n\nSimplex.prototype.flip = function() {\n  var t = this.vertices[0]\n  this.vertices[0] = this.vertices[1]\n  this.vertices[1] = t\n  var u = this.adjacent[0]\n  this.adjacent[0] = this.adjacent[1]\n  this.adjacent[1] = u\n}\n\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices\n  this.cell = cell\n  this.index = index\n}\n\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices)\n}\n\nfunction bakeOrient(d) {\n  var code = [\"function orient(){var tuple=this.tuple;return test(\"]\n  for(var i=0; i<=d; ++i) {\n    if(i > 0) {\n      code.push(\",\")\n    }\n    code.push(\"tuple[\", i, \"]\")\n  }\n  code.push(\")}return orient\")\n  var proc = new Function(\"test\", code.join(\"\"))\n  var test = orient[d+1]\n  if(!test) {\n    test = orient\n  }\n  return proc(test)\n}\n\nvar BAKED = []\n\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension\n  this.vertices = vertices\n  this.simplices = simplices\n  this.interior = simplices.filter(function(c) {\n    return !c.boundary\n  })\n\n  this.tuple = new Array(dimension+1)\n  for(var i=0; i<=dimension; ++i) {\n    this.tuple[i] = this.vertices[i]\n  }\n\n  var o = BAKED[dimension]\n  if(!o) {\n    o = BAKED[dimension] = bakeOrient(dimension)\n  }\n  this.orient = o\n}\n\nvar proto = Triangulation.prototype\n\n//Degenerate situation where we are on boundary, but coplanar to face\nproto.handleBoundaryDegeneracy = function(cell, point) {\n  var d = this.dimension\n  var n = this.vertices.length - 1\n  var tuple = this.tuple\n  var verts = this.vertices\n\n  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n  var toVisit = [ cell ]\n  cell.lastVisited = -n\n  while(toVisit.length > 0) {\n    cell = toVisit.pop()\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n    for(var i=0; i<=d; ++i) {\n      var neighbor = cellAdj[i]\n      if(!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue\n      }\n      var nv = neighbor.vertices\n      for(var j=0; j<=d; ++j) {\n        var vv = nv[j]\n        if(vv < 0) {\n          tuple[j] = point\n        } else {\n          tuple[j] = verts[vv]\n        }\n      }\n      var o = this.orient()\n      if(o > 0) {\n        return neighbor\n      }\n      neighbor.lastVisited = -n\n      if(o === 0) {\n        toVisit.push(neighbor)\n      }\n    }\n  }\n  return null\n}\n\nproto.walk = function(point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1\n  var d = this.dimension\n  var verts = this.vertices\n  var tuple = this.tuple\n\n  //Compute initial jump cell\n  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)\n  var cell = this.interior[ initIndex ]\n\n  //Start walking\nouterLoop:\n  while(!cell.boundary) {\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n\n    for(var i=0; i<=d; ++i) {\n      tuple[i] = verts[cellVerts[i]]\n    }\n    cell.lastVisited = n\n\n    //Find farthest adjacent cell\n    for(var i=0; i<=d; ++i) {\n      var neighbor = cellAdj[i]\n      if(neighbor.lastVisited >= n) {\n        continue\n      }\n      var prev = tuple[i]\n      tuple[i] = point\n      var o = this.orient()\n      tuple[i] = prev\n      if(o < 0) {\n        cell = neighbor\n        continue outerLoop\n      } else {\n        if(!neighbor.boundary) {\n          neighbor.lastVisited = n\n        } else {\n          neighbor.lastVisited = -n\n        }\n      }\n    }\n    return\n  }\n\n  return cell\n}\n\nproto.addPeaks = function(point, cell) {\n  var n = this.vertices.length - 1\n  var d = this.dimension\n  var verts = this.vertices\n  var tuple = this.tuple\n  var interior = this.interior\n  var simplices = this.simplices\n\n  //Walking finished at boundary, time to add peaks\n  var tovisit = [ cell ]\n\n  //Stretch initial boundary cell into a peak\n  cell.lastVisited = n\n  cell.vertices[cell.vertices.indexOf(-1)] = n\n  cell.boundary = false\n  interior.push(cell)\n\n  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n  var glueFacets = []\n\n  //Do a traversal of the boundary walking outward from starting peak\n  while(tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop()\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n    var indexOfN = cellVerts.indexOf(n)\n    if(indexOfN < 0) {\n      continue\n    }\n\n    for(var i=0; i<=d; ++i) {\n      if(i === indexOfN) {\n        continue\n      }\n\n      //For each boundary neighbor of the cell\n      var neighbor = cellAdj[i]\n      if(!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue\n      }\n\n      var nv = neighbor.vertices\n\n      //Test if neighbor is a peak\n      if(neighbor.lastVisited !== -n) {      \n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0\n        for(var j=0; j<=d; ++j) {\n          if(nv[j] < 0) {\n            indexOfNeg1 = j\n            tuple[j] = point\n          } else {\n            tuple[j] = verts[nv[j]]\n          }\n        }\n        var o = this.orient()\n\n        //Test if neighbor cell is also a peak\n        if(o > 0) {\n          nv[indexOfNeg1] = n\n          neighbor.boundary = false\n          interior.push(neighbor)\n          tovisit.push(neighbor)\n          neighbor.lastVisited = n\n          continue\n        } else {\n          neighbor.lastVisited = -n\n        }\n      }\n\n      var na = neighbor.adjacent\n\n      //Otherwise, replace neighbor with new face\n      var vverts = cellVerts.slice()\n      var vadj = cellAdj.slice()\n      var ncell = new Simplex(vverts, vadj, true)\n      simplices.push(ncell)\n\n      //Connect to neighbor\n      var opposite = na.indexOf(cell)\n      if(opposite < 0) {\n        continue\n      }\n      na[opposite] = ncell\n      vadj[indexOfN] = neighbor\n\n      //Connect to cell\n      vverts[i] = -1\n      vadj[i] = cell\n      cellAdj[i] = ncell\n\n      //Flip facet\n      ncell.flip()\n\n      //Add to glue list\n      for(var j=0; j<=d; ++j) {\n        var uu = vverts[j]\n        if(uu < 0 || uu === n) {\n          continue\n        }\n        var nface = new Array(d-1)\n        var nptr = 0\n        for(var k=0; k<=d; ++k) {\n          var vv = vverts[k]\n          if(vv < 0 || k === j) {\n            continue\n          }\n          nface[nptr++] = vv\n        }\n        glueFacets.push(new GlueFacet(nface, ncell, j))\n      }\n    }\n  }\n\n  //Glue boundary facets together\n  glueFacets.sort(compareGlue)\n\n  for(var i=0; i+1<glueFacets.length; i+=2) {\n    var a = glueFacets[i]\n    var b = glueFacets[i+1]\n    var ai = a.index\n    var bi = b.index\n    if(ai < 0 || bi < 0) {\n      continue\n    }\n    a.cell.adjacent[a.index] = b.cell\n    b.cell.adjacent[b.index] = a.cell\n  }\n}\n\nproto.insert = function(point, random) {\n  //Add point\n  var verts = this.vertices\n  verts.push(point)\n\n  var cell = this.walk(point, random)\n  if(!cell) {\n    return\n  }\n\n  //Alias local properties\n  var d = this.dimension\n  var tuple = this.tuple\n\n  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n  for(var i=0; i<=d; ++i) {\n    var vv = cell.vertices[i]\n    if(vv < 0) {\n      tuple[i] = point\n    } else {\n      tuple[i] = verts[vv]\n    }\n  }\n  var o = this.orient(tuple)\n  if(o < 0) {\n    return\n  } else if(o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point)\n    if(!cell) {\n      return\n    }\n  }\n\n  //Add peaks\n  this.addPeaks(point, cell)\n}\n\n//Extract all boundary cells\nproto.boundary = function() {\n  var d = this.dimension\n  var boundary = []\n  var cells = this.simplices\n  var nc = cells.length\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    if(c.boundary) {\n      var bcell = new Array(d)\n      var cv = c.vertices\n      var ptr = 0\n      var parity = 0\n      for(var j=0; j<=d; ++j) {\n        if(cv[j] >= 0) {\n          bcell[ptr++] = cv[j]\n        } else {\n          parity = j&1\n        }\n      }\n      if(parity === (d&1)) {\n        var t = bcell[0]\n        bcell[0] = bcell[1]\n        bcell[1] = t\n      }\n      boundary.push(bcell)\n    }\n  }\n  return boundary\n}\n\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length\n  if(n === 0) {\n    throw new Error(\"Must have at least d+1 points\")\n  }\n  var d = points[0].length\n  if(n <= d) {\n    throw new Error(\"Must input at least d+1 points\")\n  }\n\n  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n  var initialSimplex = points.slice(0, d+1)\n\n  //Make sure initial simplex is positively oriented\n  var o = orient.apply(void 0, initialSimplex)\n  if(o === 0) {\n    throw new Error(\"Input not in general position\")\n  }\n  var initialCoords = new Array(d+1)\n  for(var i=0; i<=d; ++i) {\n    initialCoords[i] = i\n  }\n  if(o < 0) {\n    initialCoords[0] = 1\n    initialCoords[1] = 0\n  }\n\n  //Create initial topological index, glue pointers together (kind of messy)\n  var initialCell = new Simplex(initialCoords, new Array(d+1), false)\n  var boundary = initialCell.adjacent\n  var list = new Array(d+2)\n  for(var i=0; i<=d; ++i) {\n    var verts = initialCoords.slice()\n    for(var j=0; j<=d; ++j) {\n      if(j === i) {\n        verts[j] = -1\n      }\n    }\n    var t = verts[0]\n    verts[0] = verts[1]\n    verts[1] = t\n    var cell = new Simplex(verts, new Array(d+1), true)\n    boundary[i] = cell\n    list[i] = cell\n  }\n  list[d+1] = initialCell\n  for(var i=0; i<=d; ++i) {\n    var verts = boundary[i].vertices\n    var adj = boundary[i].adjacent\n    for(var j=0; j<=d; ++j) {\n      var v = verts[j]\n      if(v < 0) {\n        adj[j] = initialCell\n        continue\n      }\n      for(var k=0; k<=d; ++k) {\n        if(boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k]\n        }\n      }\n    }\n  }\n\n  //Initialize triangles\n  var triangles = new Triangulation(d, initialSimplex, list)\n\n  //Insert remaining points\n  var useRandom = !!randomSearch\n  for(var i=d+1; i<n; ++i) {\n    triangles.insert(points[i], useRandom)\n  }\n  \n  //Extract boundary cells\n  return triangles.boundary()\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar robustSum = require(\"robust-sum\")\nvar robustScale = require(\"robust-scale\")\nvar robustSubtract = require(\"robust-subtract\")\n\nvar NUM_EXPAND = 5\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nvar ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON\n\nfunction cofactor(m, c) {\n  var result = new Array(m.length-1)\n  for(var i=1; i<m.length; ++i) {\n    var r = result[i-1] = new Array(m.length-1)\n    for(var j=0,k=0; j<m.length; ++j) {\n      if(j === c) {\n        continue\n      }\n      r[k++] = m[i][j]\n    }\n  }\n  return result\n}\n\nfunction matrix(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = new Array(n)\n    for(var j=0; j<n; ++j) {\n      result[i][j] = [\"m\", j, \"[\", (n-i-1), \"]\"].join(\"\")\n    }\n  }\n  return result\n}\n\nfunction sign(n) {\n  if(n & 1) {\n    return \"-\"\n  }\n  return \"\"\n}\n\nfunction generateSum(expr) {\n  if(expr.length === 1) {\n    return expr[0]\n  } else if(expr.length === 2) {\n    return [\"sum(\", expr[0], \",\", expr[1], \")\"].join(\"\")\n  } else {\n    var m = expr.length>>1\n    return [\"sum(\", generateSum(expr.slice(0, m)), \",\", generateSum(expr.slice(m)), \")\"].join(\"\")\n  }\n}\n\nfunction determinant(m) {\n  if(m.length === 2) {\n    return [[\"sum(prod(\", m[0][0], \",\", m[1][1], \"),prod(-\", m[0][1], \",\", m[1][0], \"))\"].join(\"\")]\n  } else {\n    var expr = []\n    for(var i=0; i<m.length; ++i) {\n      expr.push([\"scale(\", generateSum(determinant(cofactor(m, i))), \",\", sign(i), m[0][i], \")\"].join(\"\"))\n    }\n    return expr\n  }\n}\n\nfunction orientation(n) {\n  var pos = []\n  var neg = []\n  var m = matrix(n)\n  var args = []\n  for(var i=0; i<n; ++i) {\n    if((i&1)===0) {\n      pos.push.apply(pos, determinant(cofactor(m, i)))\n    } else {\n      neg.push.apply(neg, determinant(cofactor(m, i)))\n    }\n    args.push(\"m\" + i)\n  }\n  var posExpr = generateSum(pos)\n  var negExpr = generateSum(neg)\n  var funcName = \"orientation\" + n + \"Exact\"\n  var code = [\"function \", funcName, \"(\", args.join(), \"){var p=\", posExpr, \",n=\", negExpr, \",d=sub(p,n);\\\nreturn d[d.length-1];};return \", funcName].join(\"\")\n  var proc = new Function(\"sum\", \"prod\", \"scale\", \"sub\", code)\n  return proc(robustSum, twoProduct, robustScale, robustSubtract)\n}\n\nvar orientation3Exact = orientation(3)\nvar orientation4Exact = orientation(4)\n\nvar CACHED = [\n  function orientation0() { return 0 },\n  function orientation1() { return 0 },\n  function orientation2(a, b) { \n    return b[0] - a[0]\n  },\n  function orientation3(a, b, c) {\n    var l = (a[1] - c[1]) * (b[0] - c[0])\n    var r = (a[0] - c[0]) * (b[1] - c[1])\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return orientation3Exact(a, b, c)\n  },\n  function orientation4(a,b,c,d) {\n    var adx = a[0] - d[0]\n    var bdx = b[0] - d[0]\n    var cdx = c[0] - d[0]\n    var ady = a[1] - d[1]\n    var bdy = b[1] - d[1]\n    var cdy = c[1] - d[1]\n    var adz = a[2] - d[2]\n    var bdz = b[2] - d[2]\n    var cdz = c[2] - d[2]\n    var bdxcdy = bdx * cdy\n    var cdxbdy = cdx * bdy\n    var cdxady = cdx * ady\n    var adxcdy = adx * cdy\n    var adxbdy = adx * bdy\n    var bdxady = bdx * ady\n    var det = adz * (bdxcdy - cdxbdy) \n            + bdz * (cdxady - adxcdy)\n            + cdz * (adxbdy - bdxady)\n    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)\n                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)\n                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)\n    var tol = ERRBOUND4 * permanent\n    if ((det > tol) || (-det > tol)) {\n      return det\n    }\n    return orientation4Exact(a,b,c,d)\n  }\n]\n\nfunction slowOrient(args) {\n  var proc = CACHED[args.length]\n  if(!proc) {\n    proc = CACHED[args.length] = orientation(args.length)\n  }\n  return proc.apply(undefined, args)\n}\n\nfunction generateOrientationProc() {\n  while(CACHED.length <= NUM_EXPAND) {\n    CACHED.push(orientation(CACHED.length))\n  }\n  var args = []\n  var procArgs = [\"slow\"]\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    args.push(\"a\" + i)\n    procArgs.push(\"o\" + i)\n  }\n  var code = [\n    \"function getOrientation(\", args.join(), \"){switch(arguments.length){case 0:case 1:return 0;\"\n  ]\n  for(var i=2; i<=NUM_EXPAND; ++i) {\n    code.push(\"case \", i, \":return o\", i, \"(\", args.slice(0, i).join(), \");\")\n  }\n  code.push(\"}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation\")\n  procArgs.push(code.join(\"\"))\n\n  var proc = Function.apply(undefined, procArgs)\n  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    module.exports[i] = CACHED[i]\n  }\n}\n\ngenerateOrientationProc()","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar twoSum = require(\"two-sum\")\n\nmodule.exports = scaleLinearExpansion\n\nfunction scaleLinearExpansion(e, scale) {\n  var n = e.length\n  if(n === 1) {\n    var ts = twoProduct(e[0], scale)\n    if(ts[0]) {\n      return ts\n    }\n    return [ ts[1] ]\n  }\n  var g = new Array(2 * n)\n  var q = [0.1, 0.1]\n  var t = [0.1, 0.1]\n  var count = 0\n  twoProduct(e[0], scale, q)\n  if(q[0]) {\n    g[count++] = q[0]\n  }\n  for(var i=1; i<n; ++i) {\n    twoProduct(e[i], scale, t)\n    var pq = q[1]\n    twoSum(pq, t[0], q)\n    if(q[0]) {\n      g[count++] = q[0]\n    }\n    var a = t[1]\n    var b = q[1]\n    var x = a + b\n    var bv = x - a\n    var y = b - bv\n    q[1] = x\n    if(y) {\n      g[count++] = y\n    }\n  }\n  if(q[1]) {\n    g[count++] = q[1]\n  }\n  if(count === 0) {\n    g[count++] = 0.0\n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = robustSubtract\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction robustSubtract(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], -f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = -f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = -f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = linearExpansionSum\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction linearExpansionSum(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"; \"use restrict\";\n\nvar bits      = require(\"bit-twiddle\")\n  , UnionFind = require(\"union-find\")\n\n//Returns the dimension of a cell complex\nfunction dimension(cells) {\n  var d = 0\n    , max = Math.max\n  for(var i=0, il=cells.length; i<il; ++i) {\n    d = max(d, cells[i].length)\n  }\n  return d-1\n}\nexports.dimension = dimension\n\n//Counts the number of vertices in faces\nfunction countVertices(cells) {\n  var vc = -1\n    , max = Math.max\n  for(var i=0, il=cells.length; i<il; ++i) {\n    var c = cells[i]\n    for(var j=0, jl=c.length; j<jl; ++j) {\n      vc = max(vc, c[j])\n    }\n  }\n  return vc+1\n}\nexports.countVertices = countVertices\n\n//Returns a deep copy of cells\nfunction cloneCells(cells) {\n  var ncells = new Array(cells.length)\n  for(var i=0, il=cells.length; i<il; ++i) {\n    ncells[i] = cells[i].slice(0)\n  }\n  return ncells\n}\nexports.cloneCells = cloneCells\n\n//Ranks a pair of cells up to permutation\nfunction compareCells(a, b) {\n  var n = a.length\n    , t = a.length - b.length\n    , min = Math.min\n  if(t) {\n    return t\n  }\n  switch(n) {\n    case 0:\n      return 0;\n    case 1:\n      return a[0] - b[0];\n    case 2:\n      var d = a[0]+a[1]-b[0]-b[1]\n      if(d) {\n        return d\n      }\n      return min(a[0],a[1]) - min(b[0],b[1])\n    case 3:\n      var l1 = a[0]+a[1]\n        , m1 = b[0]+b[1]\n      d = l1+a[2] - (m1+b[2])\n      if(d) {\n        return d\n      }\n      var l0 = min(a[0], a[1])\n        , m0 = min(b[0], b[1])\n        , d  = min(l0, a[2]) - min(m0, b[2])\n      if(d) {\n        return d\n      }\n      return min(l0+a[2], l1) - min(m0+b[2], m1)\n    \n    //TODO: Maybe optimize n=4 as well?\n    \n    default:\n      var as = a.slice(0)\n      as.sort()\n      var bs = b.slice(0)\n      bs.sort()\n      for(var i=0; i<n; ++i) {\n        t = as[i] - bs[i]\n        if(t) {\n          return t\n        }\n      }\n      return 0\n  }\n}\nexports.compareCells = compareCells\n\nfunction compareZipped(a, b) {\n  return compareCells(a[0], b[0])\n}\n\n//Puts a cell complex into normal order for the purposes of findCell queries\nfunction normalize(cells, attr) {\n  if(attr) {\n    var len = cells.length\n    var zipped = new Array(len)\n    for(var i=0; i<len; ++i) {\n      zipped[i] = [cells[i], attr[i]]\n    }\n    zipped.sort(compareZipped)\n    for(var i=0; i<len; ++i) {\n      cells[i] = zipped[i][0]\n      attr[i] = zipped[i][1]\n    }\n    return cells\n  } else {\n    cells.sort(compareCells)\n    return cells\n  }\n}\nexports.normalize = normalize\n\n//Removes all duplicate cells in the complex\nfunction unique(cells) {\n  if(cells.length === 0) {\n    return []\n  }\n  var ptr = 1\n    , len = cells.length\n  for(var i=1; i<len; ++i) {\n    var a = cells[i]\n    if(compareCells(a, cells[i-1])) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      cells[ptr++] = a\n    }\n  }\n  cells.length = ptr\n  return cells\n}\nexports.unique = unique;\n\n//Finds a cell in a normalized cell complex\nfunction findCell(cells, c) {\n  var lo = 0\n    , hi = cells.length-1\n    , r  = -1\n  while (lo <= hi) {\n    var mid = (lo + hi) >> 1\n      , s   = compareCells(cells[mid], c)\n    if(s <= 0) {\n      if(s === 0) {\n        r = mid\n      }\n      lo = mid + 1\n    } else if(s > 0) {\n      hi = mid - 1\n    }\n  }\n  return r\n}\nexports.findCell = findCell;\n\n//Builds an index for an n-cell.  This is more general than dual, but less efficient\nfunction incidence(from_cells, to_cells) {\n  var index = new Array(from_cells.length)\n  for(var i=0, il=index.length; i<il; ++i) {\n    index[i] = []\n  }\n  var b = []\n  for(var i=0, n=to_cells.length; i<n; ++i) {\n    var c = to_cells[i]\n    var cl = c.length\n    for(var k=1, kn=(1<<cl); k<kn; ++k) {\n      b.length = bits.popCount(k)\n      var l = 0\n      for(var j=0; j<cl; ++j) {\n        if(k & (1<<j)) {\n          b[l++] = c[j]\n        }\n      }\n      var idx=findCell(from_cells, b)\n      if(idx < 0) {\n        continue\n      }\n      while(true) {\n        index[idx++].push(i)\n        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {\n          break\n        }\n      }\n    }\n  }\n  return index\n}\nexports.incidence = incidence\n\n//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices\nfunction dual(cells, vertex_count) {\n  if(!vertex_count) {\n    return incidence(unique(skeleton(cells, 0)), cells, 0)\n  }\n  var res = new Array(vertex_count)\n  for(var i=0; i<vertex_count; ++i) {\n    res[i] = []\n  }\n  for(var i=0, len=cells.length; i<len; ++i) {\n    var c = cells[i]\n    for(var j=0, cl=c.length; j<cl; ++j) {\n      res[c[j]].push(i)\n    }\n  }\n  return res\n}\nexports.dual = dual\n\n//Enumerates all cells in the complex\nfunction explode(cells) {\n  var result = []\n  for(var i=0, il=cells.length; i<il; ++i) {\n    var c = cells[i]\n      , cl = c.length|0\n    for(var j=1, jl=(1<<cl); j<jl; ++j) {\n      var b = []\n      for(var k=0; k<cl; ++k) {\n        if((j >>> k) & 1) {\n          b.push(c[k])\n        }\n      }\n      result.push(b)\n    }\n  }\n  return normalize(result)\n}\nexports.explode = explode\n\n//Enumerates all of the n-cells of a cell complex\nfunction skeleton(cells, n) {\n  if(n < 0) {\n    return []\n  }\n  var result = []\n    , k0     = (1<<(n+1))-1\n  for(var i=0; i<cells.length; ++i) {\n    var c = cells[i]\n    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {\n      var b = new Array(n+1)\n        , l = 0\n      for(var j=0; j<c.length; ++j) {\n        if(k & (1<<j)) {\n          b[l++] = c[j]\n        }\n      }\n      result.push(b)\n    }\n  }\n  return normalize(result)\n}\nexports.skeleton = skeleton;\n\n//Computes the boundary of all cells, does not remove duplicates\nfunction boundary(cells) {\n  var res = []\n  for(var i=0,il=cells.length; i<il; ++i) {\n    var c = cells[i]\n    for(var j=0,cl=c.length; j<cl; ++j) {\n      var b = new Array(c.length-1)\n      for(var k=0, l=0; k<cl; ++k) {\n        if(k !== j) {\n          b[l++] = c[k]\n        }\n      }\n      res.push(b)\n    }\n  }\n  return normalize(res)\n}\nexports.boundary = boundary;\n\n//Computes connected components for a dense cell complex\nfunction connectedComponents_dense(cells, vertex_count) {\n  var labels = new UnionFind(vertex_count)\n  for(var i=0; i<cells.length; ++i) {\n    var c = cells[i]\n    for(var j=0; j<c.length; ++j) {\n      for(var k=j+1; k<c.length; ++k) {\n        labels.link(c[j], c[k])\n      }\n    }\n  }\n  var components = []\n    , component_labels = labels.ranks\n  for(var i=0; i<component_labels.length; ++i) {\n    component_labels[i] = -1\n  }\n  for(var i=0; i<cells.length; ++i) {\n    var l = labels.find(cells[i][0])\n    if(component_labels[l] < 0) {\n      component_labels[l] = components.length\n      components.push([cells[i].slice(0)])\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0))\n    }\n  }\n  return components\n}\n\n//Computes connected components for a sparse graph\nfunction connectedComponents_sparse(cells) {\n  var vertices  = unique(normalize(skeleton(cells, 0)))\n    , labels    = new UnionFind(vertices.length)\n  for(var i=0; i<cells.length; ++i) {\n    var c = cells[i]\n    for(var j=0; j<c.length; ++j) {\n      var vj = findCell(vertices, [c[j]])\n      for(var k=j+1; k<c.length; ++k) {\n        labels.link(vj, findCell(vertices, [c[k]]))\n      }\n    }\n  }\n  var components        = []\n    , component_labels  = labels.ranks\n  for(var i=0; i<component_labels.length; ++i) {\n    component_labels[i] = -1\n  }\n  for(var i=0; i<cells.length; ++i) {\n    var l = labels.find(findCell(vertices, [cells[i][0]]));\n    if(component_labels[l] < 0) {\n      component_labels[l] = components.length\n      components.push([cells[i].slice(0)])\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0))\n    }\n  }\n  return components\n}\n\n//Computes connected components for a cell complex\nfunction connectedComponents(cells, vertex_count) {\n  if(vertex_count) {\n    return connectedComponents_dense(cells, vertex_count)\n  }\n  return connectedComponents_sparse(cells)\n}\nexports.connectedComponents = connectedComponents\n","\"use strict\"\n\nmodule.exports = twoProduct\n\nvar SPLITTER = +(Math.pow(2, 27) + 1.0)\n\nfunction twoProduct(a, b, result) {\n  var x = a * b\n\n  var c = SPLITTER * a\n  var abig = c - a\n  var ahi = c - abig\n  var alo = a - ahi\n\n  var d = SPLITTER * b\n  var bbig = d - b\n  var bhi = d - bbig\n  var blo = b - bhi\n\n  var err1 = x - (ahi * bhi)\n  var err2 = err1 - (alo * bhi)\n  var err3 = err2 - (ahi * blo)\n\n  var y = alo * blo - err3\n\n  if(result) {\n    result[0] = y\n    result[1] = x\n    return result\n  }\n\n  return [ y, x ]\n}","\"use strict\"\n\nmodule.exports = fastTwoSum\n\nfunction fastTwoSum(a, b, result) {\n\tvar x = a + b\n\tvar bv = x - a\n\tvar av = x - bv\n\tvar br = b - bv\n\tvar ar = a - av\n\tif(result) {\n\t\tresult[0] = ar + br\n\t\tresult[1] = x\n\t\treturn result\n\t}\n\treturn [ar+br, x]\n}","\"use strict\"; \"use restrict\";\n\nmodule.exports = UnionFind;\n\nfunction UnionFind(count) {\n  this.roots = new Array(count);\n  this.ranks = new Array(count);\n  \n  for(var i=0; i<count; ++i) {\n    this.roots[i] = i;\n    this.ranks[i] = 0;\n  }\n}\n\nvar proto = UnionFind.prototype\n\nObject.defineProperty(proto, \"length\", {\n  \"get\": function() {\n    return this.roots.length\n  }\n})\n\nproto.makeSet = function() {\n  var n = this.roots.length;\n  this.roots.push(n);\n  this.ranks.push(0);\n  return n;\n}\n\nproto.find = function(x) {\n  var x0 = x\n  var roots = this.roots;\n  while(roots[x] !== x) {\n    x = roots[x]\n  }\n  while(roots[x0] !== x) {\n    var y = roots[x0]\n    roots[x0] = x\n    x0 = y\n  }\n  return x;\n}\n\nproto.link = function(x, y) {\n  var xr = this.find(x)\n    , yr = this.find(y);\n  if(xr === yr) {\n    return;\n  }\n  var ranks = this.ranks\n    , roots = this.roots\n    , xd    = ranks[xr]\n    , yd    = ranks[yr];\n  if(xd < yd) {\n    roots[xr] = yr;\n  } else if(yd < xd) {\n    roots[yr] = xr;\n  } else {\n    roots[yr] = xr;\n    ++ranks[xr];\n  }\n}","\"use strict\"\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n","import { UI } from 'sketch';\nimport triangleField from '../main/triangle-field';\n\nexport default function(context) {\n  const sketchObject = context.selection.firstObject();\n  if (!sketchObject) {\n    context.document.showMessage('Select a shape!');\n    // UI.alert('Error', 'Select a shape!');\n    return;\n  }\n  triangleField(context, sketchObject, 20, 20);\n}\n","import { getRandomColor } from '../util/Math';\n\nfunction createLine(p1, p2) {\n  const path = NSBezierPath.bezierPath();\n  path.moveToPoint(NSMakePoint(p1.getX(), p1.getY()));\n  path.lineToPoint(NSMakePoint(p2.getX(), p2.getY()));\n\n  const shape = MSShapeGroup.shapeWithBezierPath(MSPath.pathWithBezierPath(path));\n  const border = shape.style().addStylePartOfType(1);\n  border.color = MSColor.colorWithRGBADictionary(getRandomColor());\n  border.thickness = 2;\n  shape.name = 'name test'\n  return shape;\n}\n\nexport default class Line {\n  constructor(p1, p2) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.id = [ ...this.p1.getId(), ...this.p2.getId() ]\n      .sort((a, b) => a - b)\n      .reduce((acc, num) => `${acc}${num}`, '');\n  }\n\n  getShape() {\n    return createLine(this.p1, this.p2);\n  }\n\n  getId() {\n    return this.id;\n  }\n}\n","import { getRandomColor } from '../util/Math';\n\nfunction createOval(centerPoint, radius, name) {\n  const ovalShape = MSOvalShape.alloc().init();\n  ovalShape.frame = MSRect.rectWithRect(NSMakeRect(centerPoint.getX(), centerPoint.getY(), radius, radius));\n  const shapeGroup = MSShapeGroup.shapeWithPath(ovalShape);\n  const fill = shapeGroup.style().addStylePartOfType(0);\n  fill.color = MSColor.colorWithRGBADictionary(getRandomColor());\n  shapeGroup.name = name || 'Point';\n  return shapeGroup;\n}\n\nexport default class Oval {\n  constructor(center, radius, name) {\n    this.center = center.clone().sub(radius / 2);\n    this.radius = radius;\n    this.name = name;\n  }\n\n  getShape() {\n    return createOval(this.center, this.radius, this.name);\n  }\n}\n","\nexport default class Point {\n  constructor(x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  // TODO: change to addScalar\n  sub(scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n  }\n\n  add(p) {\n    return new Point(\n      this.x + p.x,\n      this.y + p.y\n    );\n  }\n\n  multScalar(scalar) {\n    return new Point(\n      this.x * scalar,\n      this.y * scalar\n    );\n  }\n\n  // TODO: change to getArrayFromElements\n  getId() {\n    return [ this.x, this.y ];\n  }\n\n  clone() {\n    return new Point(this.x, this.y);\n  }\n}\n","import { getRandomColor } from '../util/Math';\n\nfunction createTriangle(p1, p2, p3) {\n  const path = NSBezierPath.bezierPath();\n  path.moveToPoint(NSMakePoint(p1.getX(), p1.getY()));\n  path.lineToPoint(NSMakePoint(p2.getX(), p2.getY()));\n  path.lineToPoint(NSMakePoint(p3.getX(), p3.getY()));\n  path.closePath();\n\n  const shape = MSShapeGroup.shapeWithBezierPath(MSPath.pathWithBezierPath(path));\n  // const border = shape.style().addStylePartOfType(1);\n  // border.color = MSColor.colorWithRGBADictionary(getRandomColor());\n  // border.thickness = 1;\n  const fill = shape.style().addStylePartOfType(0); // `0` constant indicates that we need a `fill` part to be created\n  fill.color = MSColor.colorWithRGBADictionary(getRandomColor());\n  return shape;\n}\n\nexport default class Triangle {\n  constructor(p1, p2, p3) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n  }\n\n  getShape() {\n    return createTriangle(this.p1, this.p2, this.p3);\n  }\n}\n","import { Types } from 'sketch';\nimport { Group } from 'sketch/dom';\nimport delaunayTriangulate from 'delaunay-triangulate';\nimport { getRandomNum, getCentroid } from '../util/Math';\nimport { pointIsInsidePolygon } from '../util/Intersection';\nimport Point from '../geometry/Point';\nimport Triangle from '../geometry/Triangle';\nimport Oval from '../geometry/Oval';\nimport Line from '../geometry/Line';\n\nconst FIELD_SIZE = 100;\n\nfunction getBounds(points) {\n  const dimensions = {\n    minX: Number.MAX_VALUE,\n    maxX: Number.MIN_VALUE,\n    minY: Number.MAX_VALUE,\n    maxY: Number.MIN_VALUE,\n  };\n  const fieldDimensions = points.reduce((dims, point) => {\n    const x = point.getX();\n    const y = point.getY();\n    if (x < dims.minX) { dims.minX = x; }\n    if (x > dims.maxX) { dims.maxX = x; }\n    if (y < dims.minY) { dims.minY = y; }\n    if (y > dims.maxY) { dims.maxY = y; }\n    return dims;\n  }, dimensions);\n  fieldDimensions.rangeX = fieldDimensions.maxX - fieldDimensions.minX;\n  fieldDimensions.rangeY = fieldDimensions.maxY - fieldDimensions.minY;\n  return fieldDimensions;\n}\n\nfunction createField(numPoints, edgePoints) {\n  const centroid = getCentroid(edgePoints);\n  const bounds = getBounds(edgePoints);\n  let points = [];\n  while (points.length < numPoints) {\n    const potentialPoint = new Point(\n      getRandomNum(bounds.rangeX) + bounds.minX,\n      getRandomNum(bounds.rangeY) + bounds.minY,\n    );\n    if (pointIsInsidePolygon(edgePoints, potentialPoint)) {\n      points.push(potentialPoint);\n    }\n  }\n  return { points };\n}\n\nfunction getPointsFromShape(shape, numPoints) {\n  const path = shape.pathInFrameWithTransforms();\n  const bezierPath = NSBezierPath.bezierPathWithPath(path);\n\n  const length = Math.floor(bezierPath.length());\n  const stride = length / numPoints;\n  const indices = new Array(numPoints).fill(null).map((n, i) => Math.floor(i * stride));\n\n  // TODO: use control points:\n  // console.log(length, bezierPath)\n  // for (let i = 0; i < 20; i++) {\n  //   console.log(bezierPath.pointAtIndex(i));\n  // }\n\n  const points = indices.map(index => {\n    const { x, y } = bezierPath.pointOnPathAtLength(index);\n    return new Point(x, y);\n  });\n  return points;\n}\n\nexport default function(context, shape, numEdgePoint, numPoints) {\n  const page = context.document.currentPage();\n  const edgePoints = getPointsFromShape(shape, numEdgePoint);\n  const pointField = createField(numPoints, edgePoints);\n  const allPoints = pointField.points.concat(edgePoints);\n\n  const pointArray = allPoints.map(point => point.getId());\n  const triangleIndices = delaunayTriangulate(pointArray);\n\n  const trianglePoints = triangleIndices.map(([i0, i1, i2]) => ({\n    p0: allPoints[i0],\n    p1: allPoints[i1],\n    p2: allPoints[i2],\n  }));\n\n  // TODO: remove lines for lines in concave space - generate point on line and do intersection test\\\n\n  const lineLayers = trianglePoints\n    .map(({ p0, p1, p2 }) => {\n      const line0 = new Line(p0, p1);\n      const line1 = new Line(p1, p2);\n      const line2 = new Line(p2, p0);\n      return [ line0, line1, line2 ];\n    })\n    .reduce((uniqueList, triangleLines) => {\n      triangleLines.forEach(line => {\n        if (!uniqueList.some(_line => _line.getId() === line.getId())) {\n          uniqueList.push(line);\n        }\n      });\n      return uniqueList;\n    }, [])\n    .map(line => line.getShape());\n\n  const triangleLayers = trianglePoints\n    .map(({ p0, p1, p2}) => new Triangle(p0, p1, p2))\n    .map(triangle => triangle.getShape());\n\n  const pointLayers = allPoints\n    .map((p, index) => new Oval(p, 2, `Point${index}`))\n    .map(oval => oval.getShape());\n\n  const parentGroup = new Group({\n    parent: page,\n    name: 'triangle field'\n  });\n\n  const triangleGroup = new Group({\n    parent: parentGroup,\n    name: 'triangles',\n    layers: triangleLayers,\n  });\n\n  const lineGroup = new Group({\n    parent: parentGroup,\n    name: 'lines',\n    layers: lineLayers,\n  });\n\n  const pointGroup = new Group({\n    parent: parentGroup,\n    name: 'points',\n    layers: pointLayers,\n  });\n\n  triangleGroup.adjustToFit();\n  lineGroup.adjustToFit();\n  pointGroup.adjustToFit();\n  parentGroup.adjustToFit();\n}\n","import Point from '../geometry/Point';\n\nconst ORIENTATION = {\n  COLINEAR: 'COLINEAR',\n  CLOCKWISE: 'CLOCKWISE',\n  COUNTERCLOCKWISE: 'COUNTERCLOCKWISE'\n};\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) &&\n         q.x >= Math.min(p.x, r.x) &&\n         q.y <= Math.max(p.y, r.y) &&\n         q.y >= Math.min(p.y, r.y);\n}\n\nfunction getOrientation(p, q, r) {\n  const orientation = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if (orientation === 0) {\n    return ORIENTATION.COLINEAR;\n  }\n  return (orientation > 0) ? ORIENTATION.CLOCKWISE : ORIENTATION.COUNTERCLOCKWISE;\n}\n\nfunction linesDoIntersect(p1, q1, p2, q2) {\n  const o1 = getOrientation(p1, q1, p2);\n  const o2 = getOrientation(p1, q1, q2);\n  const o3 = getOrientation(p2, q2, p1);\n  const o4 = getOrientation(p2, q2, q1);\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n  if (o1 === ORIENTATION.COLINEAR && onSegment(p1, p2, q1)) { return true; }\n  if (o2 === ORIENTATION.COLINEAR && onSegment(p1, q2, q1)) { return true; }\n  if (o3 === ORIENTATION.COLINEAR && onSegment(p2, p1, q2)) { return true; }\n  if (o4 === ORIENTATION.COLINEAR && onSegment(p2, q1, q2)) { return true; }\n  return false;\n}\n\nexport function pointIsInsidePolygon(polygon, p) {\n  if (polygon.length < 3) {\n    throw new Error('Polygon must have at least 3 points');\n  }\n  const n  = polygon.length;\n  const extreme = new Point(Number.MAX_VALUE, p.y);\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    const nextIndex = (i + 1) % n;\n    // p-etreme intersects with polygon[i]-polygon[nextIndex]\n    if (linesDoIntersect(polygon[i], polygon[nextIndex], p, extreme)) {\n      // p is colinear with i-next and it lies on segment\n      if (getOrientation(polygon[i], p, polygon[nextIndex]) === ORIENTATION.COLINEAR) {\n        return onSegment(polygon[i], p, polygon[nextIndex]);\n      }\n      count++;\n    }\n  }\n  return count % 2 == 1; // odd number of intersections\n}\n","import Point from '../geometry/Point';\n\nfunction getPosNeg() {\n  return Math.random() < 0.5 ? -1 : 1;\n}\n\nexport function getRandomColor() {\n  return {\n    r: Math.random(),\n    g: Math.random(),\n    b: Math.random(),\n    a: 1,\n  };\n}\n\nexport function getRandomNum(mult) {\n  return mult * Math.random();\n}\n\nexport function IntArray(size) {\n  return new Array(size).fill(null).map((n, i) => i);\n}\n\nexport function getCentroid(points) {\n  if (!points || !points.length) { return new Point(0, 0); }\n  const sum = points.reduce((s, p) => s.add(p), new Point(0, 0));\n  return sum.multScalar(1 / points.length);\n}\n","module.exports = require(\"sketch\");","module.exports = require(\"sketch/dom\");"],"sourceRoot":""}